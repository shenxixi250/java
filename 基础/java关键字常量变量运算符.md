### JDK与JRE的区别
![kengkeng]() 

### java程序的三个开发步骤

第一步（编译）：创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用。   
 编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。

第二步（运行）：java类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！

[完整的流程图实例](https://blog.csdn.net/super_YC/article/details/71439786) 
[kengkeng](要把博客的内容填充进去) 

### 常量
| 类型       | 含义        | 数据举例                       |
|------------|-------------|--------------------------------|
| 整数常量   | 所有的整数  | 0,1, 567, -9                   |
| 小数常量   | 所有的小数  | 0.0, -0.1, 2.55          |
| 字符常量   | 单引号引起来,只能写一个字符,必须有内容   | 'a' , ' ', '好'          |
| 字符串常量 | 双引号引起来,可以写多个字符,也可以不写 | "A" ,"Hello" ,"你好" ,"" |
| 布尔常量   | 只有两个值流程控制中讲解)               | true , false             |
| 空常量     | 只有一个值(  引用数据类型中讲解)            | null                     |


### 变量数据类型
|数据类型|关键字|内存占用|取值范围| 
|--------------|--------------|---------|------------------------|
| 字节型       | byte         | 1个字节 | -128~127               |
| 短整型       | short        | 2个字节 | -32768~32767           |
| 整型         | int(默认)    | 4个字节 | -231次方~2的31次方-1   |
| 长整型       | long         | 8个字节 | -2的63次方~2的63次方-1 |
| 单精度浮点数 | float        | 4个字节 | 1.4013E-45~3.4028E+38  |
| 双精度浮点数 | double(默认) | 8个字节 | 4.9E-324~1.7977E+308   |
| 字符型       | char         | 2个字节 | 0-65535                |
| 布尔类型     | boolean      | 1个字节 | true,false             |

数据类型 变量名 = 数据值;
注意事项 变量赋值:定义的变量,不赋值不能使用。

### 数据类型转换

1.强制类型转换 
自己手动执行 数据类型 变量名 = (数据类型)被转数据值;
```
// double类型数据强制转成int类型,直接去掉小数点。
int i = (int)1.5;
```
```
public static void main(String[] args) {
//short类型变量,内存中2个字节
short s = 1;
/*
出现编译失败
s和1做运算的时候,1是int类型,s会被提升为int类型
s+1后的结果是int类型,将结果在赋值会short类型时发生错误
short内存2个字节,int类型4个字节
必须将int强制转成short才能完成赋值
*/
s = s + 1;//编译失败
s = (short)(s+1);//编译成功
s++;//编译成功
}
```
2.自动转换

一般两个类型 如byte和int 或者char和int  都可以  

将 取值范围小的类型 自动提升为 取值范围大的类型 。转换规则
范围小的类型向范围大的类型提升, byte 、short、char 运算时直接提升为 int 。
float转化为double  等等总的来说就是小变大 这一回事吧.


###运算符  

| 算数运算符包括: | 功能                         |
|-----------------|------------------------------|
| +     | 1 加法运算   2字符串连接运算 |
| -     | 减法运算                     |
| *     | 乘法运算                     |
| /     | 除法运算                     |
| %     | 取模运算,两个数字相除取余数  |
| ++,-- | 自增自减运算                 |


| 赋值运算符包括:                                                      | 功能   |
|----------------------------------------------------------------------|--------|
| =                                                                    | 等于号 |
| +=                                                                   | 加等于 |
| -=                                                                   | 减等于 |
| *=                                                                   | 乘等于 |
| /=                                                                   | 除等于 |
| %=                                                                   | 取模等 |


| 比较运算符包括: | 功能                                                              |
|-----------------|-------------------------------------------------------------------|
| ==              | 比较符号两边数据是否相等,相等结果是true 。                        |
| <               | 比较符号左边的数据是否小于右边的数据,如果小于结果是true。         |
| >               | 比较符号左边的数据是否大于右边的数据,如果大于结果是true。         |
| <=              | 比较符号左边的数据是否小于或者等于右边的数据,如果小于结果是true。 |
| >=              | 比较符号左边的数据是否大于或者等于右边的数据,如果小于结果是true。 |
| !=              | 不等于符号 ,如果符号两边的数据不相等,结果是true。                 |




| 逻辑运算符包括: | 功能 |
|-----------------|------|
| && 短路与            | 1. 两边都是true,结果是true2. 一边是false,结果是false3 短路特点:符号左边是false,右边不再运算|
| 短路或     | 1. 两边都是false,结果是false 2. 一边是true,结果是true短路特点: 符号左边是true,右边不再运算 |
| !取反   | !true=false  |


###三元运算符  

三元运算符格式:
```
数据类型 变量名 = 布尔类型表达式?结果1:结果2
```
三元运算符计算方式:
布尔类型表达式结果是 true,三元运算符整体结果为结果1,赋值给变量。
布尔类型表达式结果是 false,三元运算符整体结果为结果2,赋值给变量。
```
public static void main(String[] args) {
int i = (1==2 ? 100 : 200);
System.out.println(i);//200
int j = (3<=4 ? 500 : 600);
System.out.println(j);//500
}
```


