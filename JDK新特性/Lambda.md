## Lambda表达式

在数学中,函数就是有输入量、输出量的一套计算方案,也就是“拿什么东西做什么事情”。相对而言,面向对象过 分强调“必须通过对象的形式来做事情”,而函数式思想则尽量忽略面向对象的复杂语法——强调做什么,而不是以 什么形式做。
面向对象的思想:
做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.  函数式编程思想: 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程


传统完成一个Runable的代码
```
public class Demo01Runnable {
public static void main(String[] args) {
// 匿名内部类
Runnable task = new Runnable() {
@Override
public void run() { // 覆盖重写抽象方法
System.out.println("多线程任务执行!");
}
};
new Thread(task).start(); // 启动线程
}
}
```
对于 Runnable 的匿名内部类用法,可以分析出几点内容:
+ Thread 类需要 Runnable 接口作为参数,其中的抽象 run 方法是用来指定线程任务内容的核心;
+ 为了指定 run 的方法体,不得不需要 Runnable 接口的实现类;
+ 为了省去定义一个 RunnableImpl 实现类的麻烦,不得不使用匿名内部类;
+ 必须覆盖重写抽象 run 方法,所以方法名称、方法参数、方法返回值不得不再写一遍,且不能写错;
+ 而实际上,似乎只有方法体才是关键所在。


### 编程思想转换
做什么,而不是怎么做
+ 我们真的希望创建一个匿名内部类对象吗?不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做
+ 的事情是:将 run 方法体内的代码传递给 Thread 类知晓。
+ 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。
+ 那,有没有更加简单的办法?如果我们将关注点从“怎么做”回归到“做什么”的本质上,就会发现只要能够更好地达
+ 到目的,过程与形式其实并不重要。


总结就是我只要结果至于你是怎么实现的我不关心   无论是面向对象还是面向过程的还是什么其他的方式
生活中的例子就是当我们需要从北京到上海时,可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海,而如何才能到达 上海的形式并不重要,所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。

借助Java 8的全新语法,上述 Runnable 接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效:
```
public class Demo02LambdaRunnable {
public static void main(String[] args) {
new Thread(() ‐> System.out.println("多线程任务执行!")).start(); // 启动线程
}
}
```
这段代码和刚才的执行效果是完全一样的,可以在1.8或更高的编译级别下通过。从代码的语义中可以看出:我们 启动了一个线程,而线程任务的内容以一种更加简洁的形式被指定。 不再有“不得不创建接口对象”的束缚,不再有“抽象方法覆盖重写”的负担,就是这么简单!

了解一下之后详细学习语法
 [Lambda详细教程](https://www.runoob.com/java/java8-lambda-expressions.html) 
